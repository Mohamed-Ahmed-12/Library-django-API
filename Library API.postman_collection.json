{
	"info": {
		"_postman_id": "f324aee3-ebb6-4cf6-b744-b4a7a775a8b4",
		"name": "Library API",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "26150263"
	},
	"item": [
		{
			"name": "Book",
			"item": [
				{
					"name": "add book",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 400\", function () {",
									"    pm.expect(pm.response.code).to.equal(400);",
									"});",
									"",
									"",
									"pm.test(\"Response content type is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"ISBN field is a non-empty array\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('object');",
									"  pm.expect(responseData.isbn).to.be.an('array').and.to.have.lengthOf.at.least(1, \"ISBN field should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Response contains the expected error message for the ISBN field\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.isbn).to.exist.and.to.be.an('array').that.is.not.empty;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "title",
									"value": "Django 5 by Example",
									"type": "text"
								},
								{
									"key": "author",
									"value": "3",
									"type": "text"
								},
								{
									"key": "publisher",
									"value": "Packet",
									"type": "text"
								},
								{
									"key": "publication_year",
									"value": "2024-05-02",
									"type": "text"
								},
								{
									"key": "isbn",
									"value": "1805125451",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "127.0.0.1:8000/api/books/add/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								"add",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "update book",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required fields\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData).to.have.property('id');",
									"    pm.expect(responseData).to.have.property('title');",
									"    pm.expect(responseData).to.have.property('publisher');",
									"    pm.expect(responseData).to.have.property('publication_year');",
									"    pm.expect(responseData).to.have.property('isbn');",
									"    pm.expect(responseData).to.have.property('genre');",
									"    pm.expect(responseData).to.have.property('author');",
									"});",
									"",
									"",
									"pm.test(\"Title is a non-empty string\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('object');",
									"  pm.expect(responseData.title).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Title should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Publication year is a valid year format\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.publication_year).to.match(/^\\d{4}$/);",
									"});",
									"",
									"",
									"pm.test(\"ISBN is in a valid format\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData.isbn).to.match(/^\\d{3}-\\d{10}$/);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "title",
									"value": "Bitcoin For Dummies",
									"type": "text"
								},
								{
									"key": "author",
									"value": "1",
									"type": "text"
								},
								{
									"key": "publisher",
									"value": "For Dummies",
									"type": "text"
								},
								{
									"key": "publication_year",
									"value": "2022-05-02",
									"type": "text"
								},
								{
									"key": "isbn",
									"value": "1119602130",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "127.0.0.1:8000/api/books/update/1/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								"update",
								"1",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "delete book",
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/books/delete/1/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								"delete",
								"1",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "get a book by id",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 404\", function () {",
									"    pm.expect(pm.response.code).to.equal(404);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required field 'detail'\", function () {",
									"    const responseData = pm.response.json();",
									"    pm.expect(responseData.detail).to.exist;",
									"});",
									"",
									"",
									"pm.test(\"Content-Type header is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Detail field is a non-empty string\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.detail).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/books/1/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								"1",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "get books",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 200\", function () {",
									"    pm.expect(pm.response.code).to.equal(200);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required fields\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('array');",
									"  responseData.forEach(function(book) {",
									"    pm.expect(book).to.have.property('id');",
									"    pm.expect(book).to.have.property('title');",
									"    pm.expect(book).to.have.property('publisher');",
									"    pm.expect(book).to.have.property('publication_year');",
									"    pm.expect(book).to.have.property('isbn');",
									"    pm.expect(book).to.have.property('genre');",
									"    pm.expect(book).to.have.property('author');",
									"  });",
									"});",
									"",
									"",
									"pm.test(\"Title, publisher, publication_year, isbn, and genre are non-empty strings\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('array');",
									"  responseData.forEach(function(book) {",
									"    pm.expect(book.title).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Title should not be empty\");",
									"    pm.expect(book.publisher).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Publisher should not be empty\");",
									"    pm.expect(book.publication_year).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Publication year should not be empty\");",
									"    pm.expect(book.isbn).to.be.a('string').and.to.have.lengthOf.at.least(1, \"ISBN should not be empty\");",
									"    pm.expect(book.genre).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Genre should not be empty\");",
									"  });",
									"});",
									"",
									"",
									"pm.test(\"ISBN is in a valid format\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('array');",
									"    responseData.forEach(function(book) {",
									"        pm.expect(book.isbn).to.match(/^\\d{3}-\\d{10}$/);",
									"    });",
									"});",
									"",
									"",
									"pm.test(\"Author is a non-negative integer\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('array');",
									"  responseData.forEach(function(book) {",
									"    pm.expect(book.author).to.be.a('number');",
									"    pm.expect(book.author).to.be.at.least(0);",
									"  });",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/books/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								""
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Book Search",
			"item": [
				{
					"name": "by title or author",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 404\", function () {",
									"    pm.expect(pm.response.code).to.equal(404);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required fields\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.detail).to.exist;",
									"});",
									"",
									"",
									"pm.test(\"Content type is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Detail is a non-empty string\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('object');",
									"  pm.expect(responseData.detail).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/books/?search=bit",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								""
							],
							"query": [
								{
									"key": "search",
									"value": "bit"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Author",
			"item": [
				{
					"name": "get authors",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"",
									"pm.test(\"Content-Type header is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Validate the structure of the author object\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('array');",
									"    responseData.forEach(function(author) {",
									"        pm.expect(author).to.be.an('object');",
									"        pm.expect(author.id).to.exist.and.to.be.a('number');",
									"        pm.expect(author.name).to.exist.and.to.be.a('string');",
									"    });",
									"});",
									"",
									"",
									"pm.test(\"Id is a non-negative integer\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('array');",
									"    responseData.forEach(function(author) {",
									"        pm.expect(author.id).to.be.a('number').and.to.be.at.least(0);",
									"    });",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/authors/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"authors",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "get an author by id",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required fields - id and name\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('object');",
									"  pm.expect(responseData).to.have.property('id');",
									"  pm.expect(responseData).to.have.property('name');",
									"});",
									"",
									"",
									"pm.test(\"Id is a non-negative integer\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.id).to.be.a('number').and.to.satisfy((id) => id >= 0, \"Id should be a non-negative integer\");",
									"});",
									"",
									"",
									"pm.test(\"Name is a non-empty string\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.name).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Name should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Content-Type header is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/authors/1/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"authors",
								"1",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "add author",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 201\", function () {",
									"    pm.expect(pm.response.code).to.equal(201);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required fields - id and name\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData).to.have.property('id');",
									"    pm.expect(responseData).to.have.property('name');",
									"});",
									"",
									"",
									"pm.test(\"Name is a non-empty string\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('object');",
									"  pm.expect(responseData.name).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Name should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Content-Type header is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Id is a non-negative integer\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.id).to.be.a('number').and.to.be.at.least(0);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "name",
									"value": "Antonio MelÃ©",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "127.0.0.1:8000/api/authors/add/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"authors",
								"add",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "update author",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 404\", function () {",
									"    pm.expect(pm.response.code).to.equal(404);",
									"});",
									"",
									"",
									"pm.test(\"Content-Type header is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Response has the required field 'detail'\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.detail).to.exist;",
									"});",
									"",
									"",
									"pm.test(\"Detail field must be a non-empty string\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.detail).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Endpoint path is correct and ID parameter is valid\", function () {",
									"    pm.expect(pm.request.url).to.include(\"127.0.0.1:8000/api/authors/update/2\");",
									"    pm.expect(pm.response.json().detail).to.exist;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "name",
									"value": "Antonio Mele",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "127.0.0.1:8000/api/authors/update/2/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"authors",
								"update",
								"2",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "delete author",
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/authors/delete/2/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"authors",
								"delete",
								"2",
								""
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Authentication",
			"item": [
				{
					"name": "Login & Get token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json(); // Parse JSON response\r",
									"\r",
									"// Save tokens into environment variables\r",
									"pm.environment.set(\"accessToken\", response.access);\r",
									"pm.environment.set(\"refreshToken\", response.refresh);\r",
									"\r",
									"// Log to confirm\r",
									"console.log(\"Access Token Saved:\", response.access);\r",
									"console.log(\"Refresh Token Saved:\", response.refresh);",
									"pm.test(\"Response status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required fields - refresh and access\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData).to.have.property('refresh');",
									"    pm.expect(responseData).to.have.property('access');",
									"});",
									"",
									"",
									"pm.test(\"Refresh token is a non-empty string\", function () {",
									"    const responseData = pm.response.json();",
									"",
									"    pm.expect(responseData.refresh).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Refresh token should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Access token is a non-empty string\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData.access).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Access token should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Response content type is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "username",
									"value": "{{username}}",
									"type": "text"
								},
								{
									"key": "password",
									"value": "{{password}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "127.0.0.1:8000/api/token/obtain/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"token",
								"obtain",
								""
							]
						},
						"description": "\n### POST /api/token/obtain/\n\nThis endpoint is used to obtain a new access token and refresh token by providing the username and password in the request payload.\n\n#### Request Body\n- `username` (text): The username of the user.\n- `password` (text): The password of the user.\n\n#### Response\nThe response is in JSON format with the following schema:\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"refresh\": {\n      \"type\": \"string\"\n    },\n    \"access\": {\n      \"type\": \"string\"\n    }\n  }\n}\n```\n\nThe response contains the `refresh` token and `access` token upon successful authentication.\n\n"
					},
					"response": []
				},
				{
					"name": "Sign up",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 400\", function () {",
									"  pm.expect(pm.response.code).to.equal(400);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required Content-Type header with value application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Response contains an array with the key 'username'\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.username).to.exist.and.to.be.an('array');",
									"});",
									"",
									"",
									"pm.test(\"Username field should be a non-empty string or array\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.username).to.exist.and.to.satisfy((value) => {",
									"        return (typeof value === 'string' && value.length > 0) || (Array.isArray(value) && value.length > 0);",
									"    }, \"Username should be a non-empty string or array\");",
									"});",
									"",
									"",
									"pm.test(\"Verify that the response does not contain any other unnecessary fields\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(Object.keys(responseData)).to.have.lengthOf(1, \"Response should only contain 'username' field\");",
									"    pm.expect(responseData.username).to.be.an('array').and.to.have.lengthOf(1, \"Username field should be an array with at least one element\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "username",
									"value": "mohamed",
									"type": "text"
								},
								{
									"key": "email",
									"value": "ma533869@gmail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "password",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "http://127.0.0.1:8000/api/signup/",
							"protocol": "http",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"signup",
								""
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Fav Books",
			"item": [
				{
					"name": "Add book to Fav",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 404\", function () {",
									"    pm.expect(pm.response.code).to.equal(404);",
									"});",
									"",
									"",
									"pm.test(\"Response has the required fields\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.detail).to.exist;",
									"});",
									"",
									"",
									"pm.test(\"Detail field is a non-empty string\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.be.an('object');",
									"  pm.expect(responseData.detail).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Detail field should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Content-Type header is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Verify the request URL is correct\", function () {",
									"    pm.expect(pm.request.url.toString()).to.equal(\"http://127.0.0.1:8000/api/books/fav/add/1/\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/books/fav/add/1/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								"fav",
								"add",
								"1",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Fav & Recommended books",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 200\", function () {",
									"    pm.expect(pm.response.code).to.equal(200);",
									"});",
									"",
									"",
									"pm.test(\"Content-Type header is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Favorites array is present and contains the expected number of elements\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.favorites).to.exist.and.to.be.an('array');",
									"    pm.expect(responseData.favorites).to.have.lengthOf.at.least(1);",
									"});",
									"",
									"",
									"pm.test(\"Recommendations array is present and contains expected number of elements\", function () {",
									"    const responseData = pm.response.json();",
									"",
									"    pm.expect(responseData).to.have.property(\"recommendations\").that.is.an('array');",
									"    pm.expect(responseData.recommendations).to.have.lengthOf(2);",
									"});",
									"",
									"",
									"pm.test(\"Favorites and recommendations have non-empty strings for title, publisher, publication_year, isbn, and genre, and a non-negative integer for author\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData.favorites).to.be.an('array');",
									"  pm.expect(responseData.recommendations).to.be.an('array');",
									"",
									"  responseData.favorites.forEach(function(favorite) {",
									"    pm.expect(favorite.title).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Title should not be empty\");",
									"    pm.expect(favorite.publisher).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Publisher should not be empty\");",
									"    pm.expect(favorite.publication_year).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Publication year should not be empty\");",
									"    pm.expect(favorite.isbn).to.be.a('string').and.to.have.lengthOf.at.least(1, \"ISBN should not be empty\");",
									"    pm.expect(favorite.genre).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Genre should not be empty\");",
									"    pm.expect(favorite.author).to.be.a('number').and.to.be.at.least(0, \"Author should be a non-negative integer\");",
									"  });",
									"",
									"  responseData.recommendations.forEach(function(recommendation) {",
									"    pm.expect(recommendation.title).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Title should not be empty\");",
									"    pm.expect(recommendation.publisher).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Publisher should not be empty\");",
									"    pm.expect(recommendation.publication_year).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Publication year should not be empty\");",
									"    pm.expect(recommendation.isbn).to.be.a('string').and.to.have.lengthOf.at.least(1, \"ISBN should not be empty\");",
									"    pm.expect(recommendation.genre).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Genre should not be empty\");",
									"    pm.expect(recommendation.author).to.be.a('number').and.to.be.at.least(0, \"Author should be a non-negative integer\");",
									"  });",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/books/fav/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								"fav",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "delete fav book",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 404\", function () {",
									"    pm.expect(pm.response.code).to.equal(404);",
									"});",
									"",
									"",
									"pm.test(\"Content-Type is application/json\", function () {",
									"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
									"});",
									"",
									"",
									"pm.test(\"Response has the required field - detail\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.detail).to.exist;",
									"});",
									"",
									"",
									"pm.test(\"Detail field is a non-empty string\", function () {",
									"    const responseData = pm.response.json();",
									"    ",
									"    pm.expect(responseData).to.be.an('object');",
									"    pm.expect(responseData.detail).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Detail should not be empty\");",
									"});",
									"",
									"",
									"pm.test(\"Response body is not empty\", function () {",
									"  const responseData = pm.response.json();",
									"  ",
									"  pm.expect(responseData).to.not.be.empty;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{accessToken}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "127.0.0.1:8000/api/books/fav/delete/1/",
							"host": [
								"127",
								"0",
								"0",
								"1"
							],
							"port": "8000",
							"path": [
								"api",
								"books",
								"fav",
								"delete",
								"1",
								""
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					"// Script to handle token refresh when expired\r",
					"\r",
					"// URL for refreshing the token\r",
					"const refreshTokenUrl = 'http://127.0.0.1:8000/api/token/refresh/';\r",
					"\r",
					"// Get the refresh token from environment variables\r",
					"const refreshToken = pm.environment.get(\"refreshToken\");\r",
					"\r",
					"// Check if the response indicates an expired token\r",
					"if (pm.response.code === 401) {\r",
					"    // Make sure a refresh token exists\r",
					"    if (!refreshToken) {\r",
					"        console.error(\"No refresh token found in environment variables.\");\r",
					"        return;\r",
					"    }\r",
					"\r",
					"    // Perform the token refresh request\r",
					"    pm.sendRequest({\r",
					"        url: refreshTokenUrl,\r",
					"        method: 'POST',\r",
					"        header: {\r",
					"            'Content-Type': 'application/json'\r",
					"        },\r",
					"        body: {\r",
					"            mode: 'raw',\r",
					"            raw: JSON.stringify({ refresh: refreshToken })\r",
					"        }\r",
					"    }, function (err, res) {\r",
					"        if (err) {\r",
					"            console.error(\"Error refreshing token:\", err);\r",
					"            return;\r",
					"        }\r",
					"\r",
					"        if (res.code === 200) {\r",
					"            const newAccessToken = res.json().access;\r",
					"            const newRefreshToken = res.json().refresh;\r",
					"\r",
					"            // Save the new tokens in environment variables\r",
					"            pm.environment.set(\"accessToken\", newAccessToken);\r",
					"            if (newRefreshToken) {\r",
					"                pm.environment.set(\"refreshToken\", newRefreshToken);\r",
					"            }\r",
					"\r",
					"            console.log(\"Tokens refreshed successfully! , Try the request now\");\r",
					"\r",
					"            // Retry the original request ,but not work if run manual\r",
					"            postman.setNextRequest(pm.request);\r",
					"        } else {\r",
					"            console.error(\"Failed to refresh token. Response:\", res.json());\r",
					"        }\r",
					"    });\r",
					"}\r",
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "username",
			"value": "admin",
			"type": "string"
		},
		{
			"key": "password",
			"value": "admin",
			"type": "string"
		}
	]
}